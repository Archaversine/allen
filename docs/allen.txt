-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/archaversine/allen#readme</a>
@package allen
@version 0.1.0.0


-- | <ul>
--   <li>Module : Data.Allen.Types</li>
--   <li>Description : Types for Allen's interval algebra.</li>
--   <li>Maintainer : Archaversine</li>
--   </ul>
module Data.Allen.Types
data Interval
Interval :: Int -> Map IntervalID RelationBits -> Interval
[intervalID] :: Interval -> Int
[intervalRelations] :: Interval -> Map IntervalID RelationBits
type Allen = State IntervalGraph
type IntervalID = Int
type IntervalGraph = Map IntervalID Interval
data Relation
Precedes :: Relation
Meets :: Relation
Overlaps :: Relation
FinishedBy :: Relation
Contains :: Relation
Starts :: Relation
Equals :: Relation
StartedBy :: Relation
During :: Relation
Finishes :: Relation
OverlappedBy :: Relation
MetBy :: Relation
PrecededBy :: Relation
type RelationBits = Word16

-- | List of all possible relations.
allRelations :: [Relation]

-- | Bit representation of all possible relations.
allRelationBits :: RelationBits

-- | Convert a Relation type to its bit representation.
toBits :: Relation -> RelationBits

-- | Convert a bit representation to a list of Relation types.
fromBits :: RelationBits -> [Relation]

-- | Calculate the union of a list of relations.
relationUnion :: [RelationBits] -> RelationBits

-- | Calculate the intersection of a list of relations.
relationIntersection :: [RelationBits] -> RelationBits

-- | Return the interval given it's ID. Panics if ID doesn't exist.
fromID :: IntervalID -> Allen Interval
instance GHC.Enum.Bounded Data.Allen.Types.Relation
instance GHC.Enum.Enum Data.Allen.Types.Relation
instance GHC.Show.Show Data.Allen.Types.Relation
instance GHC.Classes.Eq Data.Allen.Types.Relation
instance GHC.Show.Show Data.Allen.Types.Interval


-- | <ul>
--   <li>Module : Data.Allen.Relation</li>
--   <li>Description : Functions for working with Allen's interval algebra
--   relations.</li>
--   <li>Maintainer : Archaversine</li>
--   </ul>
module Data.Allen.Relation

-- | Return the converse of a Relation bitset.
converse :: RelationBits -> RelationBits

-- | Return if a relation exists between two intervals.
hasRelation :: Relation -> IntervalID -> IntervalID -> Allen Bool

-- | Compose two relations.
composeSingle :: Relation -> Relation -> RelationBits

-- | Compose two sets of relations.
compose :: RelationBits -> RelationBits -> RelationBits

-- | Given a string, return the bit representation of the set of relations.
--   Valid characters: pmoFDseSdfoMP.
--   
--   You may also use <tt>full</tt> to represent all relations, or
--   <tt>concur</tt> to represent all relations excluding Precedes and
--   PrecededBy.
bitsFromString :: String -> RelationBits


-- | This module provides functions for working with intervals. Note that
--   almost all exposed functions only work with interval IDs. This is
--   because the internal representation of intervals is subject to change,
--   but the IDs will remain the same no matter what.
--   
--   <h1>Creating intervals</h1>
--   
--   Intervals are created with the <a>interval</a> function, which creates
--   an interval adds it to the internal network representation, then
--   returns its corresponding ID. Note that upon creating a new interval,
--   it will have all relations to all other intervals. This is because the
--   creation of an interval does not provide any meaningful information
--   about its relations to other intervals.
--   
--   Creating two intervals sleeps and snores:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a>
--   </pre>
--   
--   <h1>Defining Relations Between Intervals</h1>
--   
--   There are three main ways to define relations betweek intervals:
--   
--   <ol>
--   <li>Define a single relation using the <a>Relation</a> type.</li>
--   <li>Define a set of relations using a list of <a>Relation</a>
--   types.</li>
--   <li>Define a set of relations using a <a>RelationBits</a> type.</li>
--   </ol>
--   
--   <h2>Defining a single relation</h2>
--   
--   This is the easiest to do, and is done with the <a>assume</a>
--   function. This function takes three arguments: the ID of the first
--   interval, the relation between the two intervals, and the ID of the
--   second interval.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assume</a> snores <a>During</a> sleeps
--   </pre>
--   
--   <h2>Defining a Set of Relations </h2>
--   
--   This is done with the <a>assumeSet</a> function. This function takes
--   three arguments: the ID of the first interval, a list of relations
--   between the two intervals, and the ID of the second interval.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assumeSet</a> snores [<a>StartedBy</a>, <a>During</a>, <a>FinishedBy</a>] sleeps
--   </pre>
--   
--   <h2>Defining a Set of Relations Using Bit Representation</h2>
--   
--   This is done with the <a>assumeBits</a> function. This function takes
--   three arguments: the ID of the first interval, a <a>RelationBits</a>
--   type representing the relations between the two intervals, and the ID
--   of the second interval. Generally, this function should not be used
--   directly, but it can be used to speed up calculations if you already
--   know the bit representation.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   let relations = foldl (.|.) 0 [<a>StartedBy</a>, <a>During</a>, <a>FinishedBy</a>] sleeps
--   
--   <a>assumeBits</a> snores relations sleeps
--   </pre>
--   
--   <h1>Getting Constraints</h1>
--   
--   The <a>getConstraints</a> function returns a <a>RelationBits</a> type
--   representing the set of all possible relations between two intervals.
--   This is useful for determining specific information between two
--   intervals.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assume</a> snores <a>During</a> sleeps
--   
--   <a>fromBits</a> &lt;$&gt; <a>getConstraints</a> snores sleeps
--   </pre>
module Data.Allen.Interval

-- | Create a new interval. Returns the interval ID.
interval :: Allen IntervalID

-- | Return the number of intervals that are currently in the graph.
intervalCount :: Allen Int

-- | Return the interval given it's ID. Panics if ID doesn't exist.
fromID :: IntervalID -> Allen Interval

-- | Define a relation between two intervals.
assume :: IntervalID -> Relation -> IntervalID -> Allen ()

-- | Define a set of relations between two intervals.
assumeSet :: IntervalID -> [Relation] -> IntervalID -> Allen ()

-- | Define a relation between two intervals using RelationBits.
assumeBits :: IntervalID -> RelationBits -> IntervalID -> Allen ()

-- | Set the relations between two intervals.
setRelation :: Interval -> RelationBits -> IntervalID -> Interval

-- | Return the set of possible constraints/relations between two
--   intervals.
getConstraints :: IntervalID -> IntervalID -> Allen RelationBits


-- | This module provides a monad for computing with Allen's interval
--   algebra. The monad keeps track of the interval graph that is being
--   built up during the computation. The interval graph is represented as
--   a map from interval identifiers to intervals.
--   
--   <h1>Intervals</h1>
--   
--   Intervals can be created using the <a>interval</a> function:
--   
--   <pre>
--   calc :: Allen ()
--   calc = do 
--     sleeps &lt;- interval
--     snores &lt;- interval
--     wakeup &lt;- interval
--     ...
--   </pre>
--   
--   <h2>Retrieving interval data</h2>
--   
--   Most functions perform operations on intervals solely with the use of
--   their IDs. However, sometimes it is useful to retrieve the actual
--   interval data. To get the actual interval data, use the <a>fromID</a>
--   function:
--   
--   <pre>
--   calc :: Allen () 
--   calc = do 
--     sleeps         &lt;- interval 
--     sleepsInterval &lt;- fromID sleeps
--     ...
--   </pre>
--   
--   Note that in the above example, updating the interval <tt>sleeps</tt>
--   will not update the interval <tt>sleepsInterval</tt>.
--   
--   <h2>Combining calculations</h2>
--   
--   Sometimes, it is useful to define a set of intervals in one place and
--   use then repeatedly in other places. Here is an example that reuses
--   the intervals <tt>a</tt> and <tt>b</tt>:
--   
--   <pre>
--   network :: Allen (IntervalID, IntervalID)
--   network = do 
--     a &lt;- interval 
--     b &lt;- interval 
--   
--     assume a During b 
--   
--     return (a, b)
--   
--   calc1 :: Allen () 
--   calc1 = do 
--     (a, b) &lt;- network 
--     c      &lt;- interval
--   
--     assume a Precedes c
--     ...
--   
--   calc2 :: Allen ()
--   calc2 = do 
--     (a, b) &lt;- network 
--     c      &lt;- interval 
--   
--     assume a Contains c
--     ...
--   </pre>
--   
--   <h1>Relations </h1>
--   
--   Intervals can have relations with one another. For example, in the
--   above example a valid relation would be that one sleeps during snores.
--   Adding relations is done using one of the assume functions:
--   
--   <pre>
--   calc :: Allen () 
--   calc = do 
--      sleeps &lt;- interval
--      snores &lt;- interval
--      wakeup &lt;- interval
--   
--      assume snores During sleeps
--      assume wakeup PrecededBy sleeps
--   </pre>
--   
--   Sometimes, intervals have more than one possible relation with one
--   another. For example, snores is During sleeps, but it could also by
--   StartedBy sleeps, or it could be Equals sleeps. In such cases, the
--   <tt>assumeSet</tt> function can be used:
--   
--   <pre>
--   calc :: Allen () 
--   calc = do 
--      sleeps &lt;- interval
--      snores &lt;- interval
--      wakeup &lt;- interval
--   
--      assumeSet snores [During, StartedBy, Equals] sleeps
--   </pre>
--   
--   There are thirteen different relations intervals can have with each
--   other. They are identified with the <tt>Relation</tt> type:
--   
--   <pre>
--   data Relation = Precedes 
--                 | Meets 
--                 | Overlaps 
--                 | FinishedBy
--                 | Contains 
--                 | Starts 
--                 | Equals 
--                 | StartedBy 
--                 | During 
--                 | Finishes 
--                 | OverlappedBy 
--                 | MetBy
--                 | PrecededBy
--                 deriving (Eq, Show, Enum, Bounded)
--   </pre>
module Data.Allen

-- | Return the resulting interval graph of an allen computation
execAllen :: Allen a -> IntervalGraph

-- | Return the result of an allen computation
evalAllen :: Allen a -> a

-- | Return the result of an allen computation and the resulting interval
--   graph
runAllen :: Allen a -> (a, IntervalGraph)
