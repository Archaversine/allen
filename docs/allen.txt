-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/archaversine/allen#readme</a>
@package allen
@version 0.1.0.0


-- | This module provides types that are used throughout the rest of the
--   library. This includes types for intervals, relations, and the
--   interval graph.
--   
--   <h1>Intervals</h1>
--   
--   An Interval is a data type that represents a single interval. It
--   contains an ID of type <a>IntervalID</a> and a map of relations to
--   other intervals of type Map <a>IntervalID</a> <a>RelationBits</a>.
--   
--   An <a>IntervalID</a> is essentially the same as an <tt>Int</tt>, but
--   it is helpful to have a dedicated type synonym to distinguish
--   functions that perform operations interval IDs.
--   
--   <h1>Relations</h1>
--   
--   A <a>Relation</a> is a data type that represents a relation between
--   two intervals. It is defined in terms of thirteen constructors, where
--   each constructor represents one of the thirteen possible relations in
--   Allen's interval algebra.
--   
--   The <a>RelationBits</a> is used to represent a set of possible
--   representation. It is synonymous with a <tt>Word16</tt>, and is used
--   to represent a set of possible relations. Since there are only
--   thirteen different relations, only 13 of the 16 bits in the
--   <tt>Word16</tt> are used.
--   
--   <h1>Interval Graph</h1>
--   
--   An interval graph is a map of <a>IntervalID</a>s to <a>Interval</a>s.
--   It is used to represent the network of intervals and their relations
--   to each other.
--   
--   <h1>Allen Monad</h1>
--   
--   The Allen monad is a state monad that is used to keep track of the
--   interval graph that is being built up during the computation. Since it
--   is a synonym of the <tt>State</tt> monad, it is possible to use all of
--   the functions in the <tt>Control.Monad.State</tt> module.
module Data.Allen.Types

-- | An interval is a data type that represents a single interval. It
--   contains an ID of type <a>IntervalID</a> and a map of relations to
--   other intervals of type Map <a>IntervalID</a> <a>RelationBits</a>. It
--   should not be directly used in a computation unless the
--   <a>IntervalGraph</a> is in its final state.
data Interval
Interval :: Int -> Map IntervalID RelationBits -> Interval
[intervalID] :: Interval -> Int
[intervalRelations] :: Interval -> Map IntervalID RelationBits

-- | A specific instance of the state monad that is used to keep track of
--   the <a>IntervalGraph</a> that is being built up during the
--   computation.
type Allen = State IntervalGraph

-- | How intervals are uniquely identified.
type IntervalID = Int

-- | This is the main type that is used to represent the network of
--   intervals.
type IntervalGraph = Map IntervalID Interval

-- | A type where each constructor represents one of the thirteen relations
--   in Allen's interval algebra.
data Relation

-- | In Char form: <b>p</b>
Precedes :: Relation

-- | In Char form: <b>m</b>
Meets :: Relation

-- | In Char form: <b>o</b>
Overlaps :: Relation

-- | In Char form: <b>F</b>
FinishedBy :: Relation

-- | In Char form: <b>D</b>
Contains :: Relation

-- | In Char form: <b>s</b>
Starts :: Relation

-- | In Char form: <b>e</b>
Equals :: Relation

-- | In Char form: <b>S</b>
StartedBy :: Relation

-- | In Char form: <b>d</b>
During :: Relation

-- | In Char form: <b>f</b>
Finishes :: Relation

-- | In Char form: <b>O</b>
OverlappedBy :: Relation

-- | In Char form: <b>M</b>
MetBy :: Relation

-- | In Char form: <b>P</b>
PrecededBy :: Relation

-- | A bit representation that acts as a set of possible relations between
--   intervals.
type RelationBits = Word16

-- | List of all possible relations.
allRelations :: [Relation]

-- | Bit representation of all possible relations.
allRelationBits :: RelationBits

-- | Convert a Relation type to its bit representation.
toBits :: Relation -> RelationBits

-- | Convert a bit representation to a list of Relation types.
fromBits :: RelationBits -> [Relation]

-- | Calculate the union of a list of relations.
relationUnion :: [RelationBits] -> RelationBits

-- | Calculate the intersection of a list of relations.
relationIntersection :: [RelationBits] -> RelationBits

-- | Convert a relation to its Char representation.
relationToChar :: Relation -> Char

-- | Return the interval given it's ID. Panics if ID doesn't exist.
fromID :: IntervalID -> Allen Interval
instance GHC.Enum.Bounded Data.Allen.Types.Relation
instance GHC.Enum.Enum Data.Allen.Types.Relation
instance GHC.Show.Show Data.Allen.Types.Relation
instance GHC.Classes.Eq Data.Allen.Types.Relation
instance GHC.Show.Show Data.Allen.Types.Interval


-- | This module provides functions for working with relations. Note that
--   almost all exposed functions only work with relation bitsets. This is
--   done mainly to optimize the speed in calculations involving relations.
--   
--   The <a>RelationBits</a> type is a synonym for a 16 bit unsigned
--   integer. Note that since Allen's interval algebra only defines 13
--   relations, the remaining 3 bits are unused. So the bit representation
--   of every possible relation looks like this:
--   
--   <pre>
--   0b0001111111111111
--   </pre>
--   
--   Modifying the extra 3 bits will not affect the result of any
--   calculations. To view in exact detail how a <a>Relation</a> converted
--   to a bit representation, see the <a>toBits</a> function.
module Data.Allen.Relation

-- | Return the converse of a Relation bitset.
converse :: RelationBits -> RelationBits

-- | Return if a relation exists between two intervals.
testRelation :: Relation -> IntervalID -> IntervalID -> Allen Bool

-- | Return if all relations in a set exist between two intervals.
--   
--   IF the set of relations between interval <tt>a</tt> and interval
--   <tt>b</tt> is <tt>full</tt>, then the function will always return
--   <tt>True</tt>.
testRelationSet :: [Relation] -> IntervalID -> IntervalID -> Allen Bool

-- | Return if all relations in a set exist between two intervals.
--   
--   If the set of relations between interval <tt>a</tt> and interval
--   <tt>b</tt> is <tt>full</tt>, then the function will always return
--   <tt>True</tt>.
testRelationBits :: RelationBits -> IntervalID -> IntervalID -> Allen Bool

-- | Compose two relations.
--   
--   Composition table available at
--   <a>https://www.ics.uci.edu/~alspaugh/cls/shr/allen.html</a>.
composeSingle :: Relation -> Relation -> RelationBits

-- | Compose two sets of relations.
--   
--   Composition table available at
--   <a>https://www.ics.uci.edu/~alspaugh/cls/shr/allen.html</a>.
compose :: RelationBits -> RelationBits -> RelationBits

-- | Given a string, return the bit representation of the set of relations.
--   Valid characters: pmoFDseSdfoMP.
--   
--   You may also use <tt>full</tt> to represent all relations, or
--   <tt>concur</tt> to represent all relations excluding Precedes and
--   PrecededBy.
--   
--   Example:
--   
--   <pre>
--   let x = <a>bitsFromString</a> "pms"    -- [Precedes, Meets, StartedBy]
--       y = <a>bitsFromString</a> "full"   -- [Precedes .. PrecededBy]
--       z = <a>bitsFromString</a> "concur" -- [Overlaps .. OverlappedBy]
--   </pre>
bitsFromString :: String -> RelationBits


-- | This module provides functions for working with intervals. Note that
--   almost all exposed functions only work with interval IDs. This is
--   because the internal representation of intervals is subject to change,
--   but the IDs will remain the same no matter what.
--   
--   <h1>Creating intervals</h1>
--   
--   Intervals are created with the <a>interval</a> function, which creates
--   an interval adds it to the internal network representation, then
--   returns its corresponding ID. Note that upon creating a new interval,
--   it will have all relations to all other intervals. This is because the
--   creation of an interval does not provide any meaningful information
--   about its relations to other intervals.
--   
--   Creating two intervals sleeps and snores:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a>
--   </pre>
--   
--   <h1>Defining Relations Between Intervals</h1>
--   
--   There are three main ways to define relations betweek intervals:
--   
--   <ol>
--   <li>Define a single relation using the <a>Relation</a> type.</li>
--   <li>Define a set of relations using a list of <a>Relation</a>
--   types.</li>
--   <li>Define a set of relations using a <a>RelationBits</a> type.</li>
--   </ol>
--   
--   <h2>Defining a single relation</h2>
--   
--   This is the easiest to do, and is done with the <a>assume</a>
--   function. This function takes three arguments: the ID of the first
--   interval, the relation between the two intervals, and the ID of the
--   second interval.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assume</a> snores <a>During</a> sleeps
--   </pre>
--   
--   <h2>Defining a Set of Relations </h2>
--   
--   This is done with the <a>assumeSet</a> function. This function takes
--   three arguments: the ID of the first interval, a list of relations
--   between the two intervals, and the ID of the second interval.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assumeSet</a> snores [<a>StartedBy</a>, <a>During</a>, <a>FinishedBy</a>] sleeps
--   </pre>
--   
--   <h2>Defining a Set of Relations Using Bit Representation</h2>
--   
--   This is done with the <a>assumeBits</a> function. This function takes
--   three arguments: the ID of the first interval, a <a>RelationBits</a>
--   type representing the relations between the two intervals, and the ID
--   of the second interval. Generally, this function should not be used
--   directly, but it can be used to speed up calculations if you already
--   know the bit representation.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   let relations = <a>relationUnion</a> $ map <a>toBits</a> [<a>StartedBy</a>, <a>During</a>, <a>FinishedBy</a>]
--   
--   <a>assumeBits</a> snores relations sleeps
--   </pre>
--   
--   <h1>Getting Constraints</h1>
--   
--   The <a>getConstraints</a> function returns a <a>RelationBits</a> type
--   representing the set of all possible relations between two intervals.
--   This is useful for determining specific information between two
--   intervals.
--   
--   Example:
--   
--   <pre>
--   sleeps &lt;- <a>interval</a> 
--   snores &lt;- <a>interval</a> 
--   
--   <a>assume</a> snores <a>During</a> sleeps
--   
--   <a>fromBits</a> &lt;$&gt; <a>getConstraints</a> snores sleeps
--   </pre>
module Data.Allen.Interval

-- | Create a new interval. Returns the interval ID.
interval :: Allen IntervalID

-- | Return the number of intervals that are currently in the graph.
intervalCount :: Allen Int

-- | Return the interval given it's ID. Panics if ID doesn't exist.
fromID :: IntervalID -> Allen Interval

-- | Define a relation between two intervals.
assume :: IntervalID -> Relation -> IntervalID -> Allen ()

-- | Define a set of relations between two intervals.
assumeSet :: IntervalID -> [Relation] -> IntervalID -> Allen ()

-- | Define a relation between two intervals using RelationBits.
assumeBits :: IntervalID -> RelationBits -> IntervalID -> Allen ()

-- | Given two intervals, return a copy of the first interval such that it
--   now has the specified set of relations to the second interval.
--   
--   This has no effect on the second interval or the network
--   representation.
setRelation :: Interval -> RelationBits -> IntervalID -> Interval

-- | Return the set of possible constraints/relations between two
--   intervals.
getConstraints :: IntervalID -> IntervalID -> Allen RelationBits


-- | This module provides a monad for computing with Allen's interval
--   algebra. The monad keeps track of the interval graph that is being
--   built up during the computation. The interval graph is represented as
--   a map from interval identifiers to intervals.
--   
--   <h1>Intervals</h1>
--   
--   Intervals can be created using the <a>interval</a> function:
--   
--   <pre>
--   calc :: <a>Allen</a> ()
--   calc = do 
--     sleeps &lt;- <a>interval</a>
--     snores &lt;- <a>interval</a>
--     wakeup &lt;- <a>interval</a>
--     ...
--   </pre>
--   
--   <h2>Retrieving interval data</h2>
--   
--   Most functions perform operations on intervals solely with the use of
--   their IDs. However, sometimes it is useful to retrieve the actual
--   interval data. To get the actual interval data, use the <a>fromID</a>
--   function:
--   
--   <pre>
--   calc :: Allen () 
--   calc = do 
--     sleeps         &lt;- <a>interval</a> 
--     sleepsInterval &lt;- <a>fromID</a> sleeps
--     ...
--   </pre>
--   
--   Note that in the above example, updating the interval <tt>sleeps</tt>
--   will not update the interval <tt>sleepsInterval</tt>.
--   
--   <h2>Combining calculations</h2>
--   
--   Sometimes, it is useful to define a set of intervals in one place and
--   use then repeatedly in other places. Here is an example that reuses
--   the intervals <tt>a</tt> and <tt>b</tt>:
--   
--   <pre>
--   network :: <a>Allen</a> (<a>IntervalID</a>, <a>IntervalID</a>)
--   network = do 
--     a &lt;- <a>interval</a> 
--     b &lt;- <a>interval</a> 
--   
--     <a>assume</a> a <a>During</a> b 
--   
--     return (a, b)
--   
--   calc1 :: <a>Allen</a> () 
--   calc1 = do 
--     (a, b) &lt;- network 
--     c      &lt;- <a>interval</a>
--   
--     <a>assume</a> a <a>Precedes</a> c
--     ...
--   
--   calc2 :: <a>Allen</a> ()
--   calc2 = do 
--     (a, b) &lt;- network 
--     c      &lt;- <a>interval</a>
--   
--     <a>assume</a> a <a>Contains</a> c
--     ...
--   </pre>
--   
--   <h1>Relations </h1>
--   
--   Intervals can have relations with one another. For example, in the
--   above example a valid relation would be that one sleeps during snores.
--   Adding relations is done using one of the assume functions:
--   
--   <pre>
--   calc :: Allen () 
--   calc = do 
--      sleeps &lt;- <a>interval</a>
--      snores &lt;- <a>interval</a>
--      wakeup &lt;- <a>interval</a>
--   
--      <a>assume</a> snores <a>During</a> sleeps
--      <a>assume</a> wakeup <a>PrecededBy</a> sleeps
--   </pre>
--   
--   Sometimes, intervals have more than one possible relation with one
--   another. For example, snores is <a>During</a> sleeps, but it could
--   also be <a>StartedBy</a> sleeps, or it could <a>Equals</a> sleeps. In
--   such cases, the <a>assumeSet</a> function can be used:
--   
--   <pre>
--   calc :: <a>Allen</a> () 
--   calc = do 
--      sleeps &lt;- <a>interval</a>
--      snores &lt;- <a>interval</a>
--      wakeup &lt;- <a>interval</a>
--   
--      <a>assumeSet</a> snores [<a>During</a>, <a>StartedBy</a>, <a>Equals</a>] sleeps
--   </pre>
--   
--   There are thirteen different relations intervals can have with each
--   other. They are identified with the <a>Relation</a> type.
module Data.Allen

-- | Return the resulting interval graph of an allen computation
execAllen :: Allen a -> IntervalGraph

-- | Return the result of an allen computation
evalAllen :: Allen a -> a

-- | Return the result of an allen computation and the resulting interval
--   graph
runAllen :: Allen a -> (a, IntervalGraph)
